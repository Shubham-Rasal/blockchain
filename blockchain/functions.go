package blockchain

import (
	// eth_crypto "github.com/ethereum/go-ethereum/crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	// "math"	
	// _rand "math/rand"
	// "time"

	"golang.org/x/crypto/sha3"
)

const (
	HashLength    = 32
	AddressLength = 20
)


func CreateAccount() Account {

	// cli.Parse()

	var account Account
	account.Balance = 0

	//eliptic.P256() returns a curve which implements P-256 (see FIPS 186-3, section D.2.3)
	//rand.Reader is a global, shared instance of a cryptographically strong pseudo-random generator.
	// the private key is generated using the elliptic curve algorithm
	// it generates a private key and a public key where the private key is a random number and the public key is a point on the curve
	// the public key is a point on the curve and is generated by multiplying the private key with the base point of the curve
	// the base point is a point on the curve which is known to everyone

	PrivateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		fmt.Println(err)
	}

	account.PrivateKey = PrivateKey
	account.PublicKey = PrivateKey.PublicKey
	// You get a public address for your account by taking the last 20 bytes of the Keccak-256 hash of the public key and adding 0x to the beginning.
	hasher := sha3.New256()

	// Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.
	//This is done to make sure that the point is encoded in a consistent manner. The return value is a slice of length 2*curveByteLength+1.
	//Eg := [4 20 52 66 169 136 192 138 240 147 67 118 248 11 31 44 251 227 126 85 213 88 252 76 15 43 103 241 168 123 163 134 170 195 70 203 173 194 13 40 174 127 240 241 229 40 193 156 46 242 155 73 31 131 75 234 155 204 239 142 166 151 210 95 7]
	hasher.Write(elliptic.Marshal(elliptic.P256(), account.PublicKey.X, account.PublicKey.Y))

	//hex encoding is used to convert the hash into a string
	// fmt.Println(hasher.Sum(nil))
	hash := hasher.Sum(nil)
	//take the last 20 bytes of the hash
	account.Address.SetBytes(hash)
	fmt.Println(string(account.Address.Hex()))

	return account

}






func HashBlock(block Block) string {
	//hash the block using the sha3-256 algorithm
	hasher := sha3.New256()
	hasher.Write([]byte(block.PreviousBlockHash))
	for i := 0; i < len(block.Transactions); i++ {
		hasher.Write([]byte(block.Transactions[i].TransactionHash))
	}
	// hasher.Write([]byte(string(block.Nonce)))
	return hex.EncodeToString(hasher.Sum(nil))
}
