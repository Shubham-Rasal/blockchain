package blockchain

import (
	// eth_crypto "github.com/ethereum/go-ethereum/crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"math"
	"math/big"
	_rand "math/rand"
	"time"

	"golang.org/x/crypto/sha3"
)

const (
	HashLength    = 32
	AddressLength = 20
)

//trims the hash to 32 bytes
func (h *Hash) SetBytes(b []byte) {
	if len(b) > len(h) {
		b = b[len(b)-HashLength:]
	}

	copy(h[HashLength-len(b):], b)
}

func CreateAccount() Account {

	// cli.Parse()

	var account Account
	account.Balance = 0

	//eliptic.P256() returns a curve which implements P-256 (see FIPS 186-3, section D.2.3)
	//rand.Reader is a global, shared instance of a cryptographically strong pseudo-random generator.
	// the private key is generated using the elliptic curve algorithm
	// it generates a private key and a public key where the private key is a random number and the public key is a point on the curve
	// the public key is a point on the curve and is generated by multiplying the private key with the base point of the curve
	// the base point is a point on the curve which is known to everyone

	PrivateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	if err != nil {
		fmt.Println(err)
	}

	account.PrivateKey = PrivateKey
	account.PublicKey = PrivateKey.PublicKey
	// You get a public address for your account by taking the last 20 bytes of the Keccak-256 hash of the public key and adding 0x to the beginning.
	hasher := sha3.New256()

	// Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.
	//This is done to make sure that the point is encoded in a consistent manner. The return value is a slice of length 2*curveByteLength+1.
	//Eg := [4 20 52 66 169 136 192 138 240 147 67 118 248 11 31 44 251 227 126 85 213 88 252 76 15 43 103 241 168 123 163 134 170 195 70 203 173 194 13 40 174 127 240 241 229 40 193 156 46 242 155 73 31 131 75 234 155 204 239 142 166 151 210 95 7]
	hasher.Write(elliptic.Marshal(elliptic.P256(), account.PublicKey.X, account.PublicKey.Y))

	//hex encoding is used to convert the hash into a string
	// fmt.Println(hasher.Sum(nil))
	hash := hasher.Sum(nil)
	//take the last 20 bytes of the hash
	account.Address.SetBytes(hash)
	fmt.Println(string(account.Address.Hex()))

	return account

}

type Signature struct {
	r *big.Int
	s *big.Int
	v int
} 

func CreateTransaction(account *ecdsa.PrivateKey, to string, amount int) Transaction {

	var transaction Transaction
	// transaction.From = account.PublicKey
	transaction.Recipient = to
	transaction.Amount = amount
	//store unix time in the transaction
	transaction.TimeStamp = time.Now()
	//generate a random number for the transaction
	transaction.Nonce = _rand.Intn(math.MaxInt64)
	//generate a transaction hash
	hasher := sha3.New256()
	hasher.Write([]byte(transaction.Recipient))
	hasher.Write([]byte(string(rune(transaction.Amount))))
	hasher.Write([]byte(string(rune(transaction.TimeStamp.Unix()))))
	hasher.Write([]byte(string(rune(transaction.Nonce))))
	transaction.TransactionHash = hex.EncodeToString(hasher.Sum(nil))
	//sign the transaction hash using the private key
	r, s, err := ecdsa.Sign(rand.Reader, account, []byte(transaction.TransactionHash))
	if err != nil {
		fmt.Println(err)
	}

	//the signature is a pair of numbers (r,s) which are the coordinates of the point on the curve
	//the signature is encoded as a string
	//v is the recovery id which is used to recover the public key from the signature
	transaction.Signature = Signature{r: r, s: s, v: 0}	

	return transaction
}

func VerifyTransaction(transaction Transaction) bool {

	//derive the public key from the signature
	//the public key is a point on the curve
	//the public key is derived from the signature using the recovery id
	//the recovery id is used to determine the sign of the public key
	hasher := sha3.New256()
	hasher.Write([]byte(transaction.Recipient))
	hasher.Write([]byte(string(rune(transaction.Amount))))
	hasher.Write([]byte(string(rune(transaction.TimeStamp.Unix()))))
	hasher.Write([]byte(string(rune(transaction.Nonce))))

	hash := hex.EncodeToString(hasher.Sum(nil))

	if hash != transaction.TransactionHash {
		return false
	}

	// Sign creates a recoverable ECDSA signature.
// The produced signature is in the 65-byte [R || S || V] format where V is 0 or 1.


	// signingPublicKey := eth_crypto.SigToPub()

	


	

	return true
}
	



func HashBlock(block Block) string {
	//hash the block using the sha3-256 algorithm
	hasher := sha3.New256()
	hasher.Write([]byte(block.PreviousBlockHash))
	for i := 0; i < len(block.Transactions); i++ {
		hasher.Write([]byte(block.Transactions[i].TransactionHash))
	}
	// hasher.Write([]byte(string(block.Nonce)))
	return hex.EncodeToString(hasher.Sum(nil))
}
